{"version":3,"file":"background.977db8127cf88942359f.hot-update.js","sources":["/Users/maddie/Desktop/Work/junctionx/fire-phoenix/src/background/index.js"],"sourcesContent":["import LocalStore from \"./local-store\";\nimport browser from \"webextension-polyfill\";\nimport { createEngineStream } from \"json-rpc-middleware-stream\";\nimport PortStream from \"extension-port-stream\";\nimport pump from \"pump\";\nimport { getChainIdStorage, getCurrentPageInfo, getListTrustedApps, openPopup, setupMultiplex } from \"./bgHelper\";\n// import {\n//   requestAccounts,\n//   switchChain,\n//   getChainId,\n//   getProviderState,\n//   getAccounts,\n//   signAndSendTx,\n//   personalSign,\n//   getBlockNumber,\n//   getPermittedAccounts,\n// } from \"./jsonRpcApi\";\nimport { nanoid } from \"nanoid\";\nimport { hexToNumber } from \"web3-utils\";\n\nconst JsonRpcEngine = require(\"json-rpc-engine\");\nconst KeyringController = require(\"eth-keyring-controller\");\nconst localStore = new LocalStore();\n\nlet keyringController = null;\nlet password = null;\n\nlet globalData = {\n  selectedAccount: null,\n  chainId: \"0x1\", // hex version of chainId\n  networkVersion: \"1\", // chainId\n  // Flag\n  isOpenRequestedPopup: false,\n  isRejectAccountOnce: false,\n  isRejectSwitchChainOnce: false,\n};\n\nconst connections = {};\nglobal.connections = connections;\n\ninitialize().catch(console.error);\n\nasync function initialize() {\n  const data = await localStore.get();\n\n  keyringController = new KeyringController({\n    initState: data,\n  });\n\n  global.keyringController = keyringController;\n  if (password) {\n    keyringController.submitPassword(password);\n  }\n\n  browser.runtime.onConnect.addListener(connectRemote);\n}\n\nbrowser.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  // if (request.type === \"create_new_vault\") {\n  //   keyringController.createNewVaultAndKeychain(request.password).then(() => {\n  //     password = request.password;\n  //     const mnemonic = keyringController.keyrings[0].mnemonic;\n  //     sendResponse({ mnemonic: mnemonic });\n  //   });\n  // }\n  // if (request.type === \"set_password\") {\n  //   password = request.password;\n  //   if (password) {\n  //     keyringController.submitPassword(password);\n  //   } else {\n  //     keyringController.setLocked();\n  //   }\n  //   sendResponse(password);\n  // }\n  // if (request.type === \"get_password\") {\n  //   sendResponse(password);\n  // }\n  // if (request.type === \"store_vault\") {\n  //   if (request.vault) {\n  //     localStore.set(request.vault);\n  //     sendResponse(request.vault);\n  //   } else {\n  //     const vault = keyringController.store.getState();\n  //     localStore.set(vault);\n  //     sendResponse(vault);\n  //   }\n  // }\n  // if (request.type === \"create_new_vault_and_restore\") {\n  //   keyringController\n  //     .createNewVaultAndRestore(request.password, request.mnemonic)\n  //     .then((res) => {\n  //       const vault = keyringController.store.getState();\n  //       password = request.password;\n  //       localStore.set(vault);\n  //       sendResponse({ vault, isError: false });\n  //     })\n  //     .catch((err) => {\n  //       sendResponse({ error: err.message, isError: true });\n  //     });\n  // }\n  // if (request.type === \"log\") {\n  //   console.log(request.message);\n  // }\n  if (request.type === \"get_page_info\") {\n    const pageInfo = getCurrentPageInfo(connections, request.url);\n    sendResponse(pageInfo);\n  }\n  // if (request.type === \"set_reject_account_once\") {\n  //   globalData.isRejectAccountOnce = request.isRejected;\n  //   sendResponse(request.isRejected);\n  // }\n  // if (request.type === \"set_reject_switch_chain_once\") {\n  //   globalData.isRejectSwitchChainOnce = request.value;\n  //   sendResponse(request.isRejectSwitchChainOnce);\n  // }\n  // if (request.type === \"get_chain_id\") {\n  //   sendResponse(globalData.chainId);\n  // }\n  return true;\n});\n\n// /**\n//  * A runtime.Port object, as provided by the browser:\n//  *\n//  * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port\n//  * @typedef Port\n//  * @type Object\n//  */\n\n// /**\n//  * @param {Port} remotePort - The port provided by a new context.\n//  */\nfunction connectRemote(remotePort) {\n  const connectionStream = new PortStream(remotePort);\n  const { sender } = remotePort;\n  const mux = setupMultiplex(connectionStream);\n  const outStream = mux.createStream(\"metamask-provider\");\n\n  const engine = new JsonRpcEngine();\n  const origin = new URL(sender.url).origin;\n\n  // engine.push(async (req, res, next, end) => {\n  //   const pageInfo = getCurrentPageInfo(connections, origin);\n\n    // const params = {\n    //   req,\n    //   res,\n    //   next,\n    //   end,\n    //   keyringController,\n    //   selectedAccount: globalData.selectedAccount,\n    //   chainId: globalData.chainId,\n    //   networkVersion: globalData.networkVersion,\n    //   isOpenRequestedPopup: globalData.isOpenRequestedPopup,\n    //   pageInfo,\n    // };\n    // getProviderState(params);\n    // getAccounts(params);\n    // requestAccounts(params);\n    // switchChain(params);\n    // getChainId(params);\n    // signAndSendTx(params);\n    // personalSign(params);\n    // getBlockNumber(params);\n  // });\n\n  // setup connection\n  const providerStream = createEngineStream({ engine });\n\n  const connectionId = addConnection(origin, { engine });\n\n  pump(outStream, providerStream, outStream, (err) => {\n    engine._middleware.forEach((mid) => {\n      if (mid.destroy && typeof mid.destroy === \"function\") {\n        mid.destroy();\n      }\n    });\n    connectionId && removeConnection(origin, connectionId);\n    if (err) {\n      console.log(err);\n    }\n  });\n\n  remotePort.onMessage.addListener((msg) => {\n    console.log(msg, remotePort);\n  });\n}\n\n/**\n * Adds a reference to a connection by origin. Ignores the 'metamask' origin.\n * Caller must ensure that the returned id is stored such that the reference\n * can be deleted later.\n *\n * @param {string} origin - The connection's origin string.\n * @param {Object} options - Data associated with the connection\n * @param {Object} options.engine - The connection's JSON Rpc Engine\n * @returns {string} The connection's id (so that it can be deleted later)\n */\nfunction addConnection(origin, { engine }) {\n  if (origin === \"metamask\") {\n    return null;\n  }\n\n  if (!connections[origin]) {\n    connections[origin] = {};\n  }\n\n  const id = nanoid();\n  connections[origin][id] = {\n    engine,\n  };\n\n  return id;\n}\n\n/**\n * Deletes a reference to a connection, by origin and id.\n * Ignores unknown origins.\n *\n * @param {string} origin - The connection's origin string.\n * @param {string} id - The connection's id, as returned from addConnection.\n */\nfunction removeConnection(origin, id) {\n  const data = connections[origin];\n  if (!data) {\n    return;\n  }\n\n  delete data[id];\n\n  if (Object.keys(data).length === 0) {\n    delete connections[origin];\n  }\n}\n\n/**\n * Closes all connections for the given origin, and removes the references\n * to them.\n * Ignores unknown origins.\n *\n * @param {string} origin - The origin string.\n */\nfunction removeAllConnections(origin) {\n  const connections = connections[origin];\n  if (!connections) {\n    return;\n  }\n\n  Object.keys(connections).forEach((id) => {\n    removeConnection(origin, id);\n  });\n}\n\n/**\n * Causes the RPC engines associated with the connections to the given origin\n * to emit a notification event with the given payload.\n *\n * The caller is responsible for ensuring that only permitted notifications\n * are sent.\n *\n * Ignores unknown origins.\n *\n * @param {string} origin - The connection's origin string.\n * @param {unknown} payload - The event payload.\n */\nfunction notifyConnections(origin, payload) {\n  const connections = global.connections[origin];\n  const getPayload = typeof payload === \"function\" ? (origin) => payload(origin) : () => payload;\n\n  if (connections) {\n    Object.values(connections).forEach(async (conn) => {\n      if (conn.engine) {\n        conn.engine.emit(\"notification\", await getPayload(origin));\n      }\n    });\n  }\n}\n\n/**\n * Causes the RPC engines associated with all connections to emit a\n * notification event with the given payload.\n *\n * If the \"payload\" parameter is a function, the payload for each connection\n * will be the return value of that function called with the connection's\n * origin.\n *\n * The caller is responsible for ensuring that only permitted notifications\n * are sent.\n *\n * @param {unknown} payload - The event payload, or payload getter function.\n */\nexport function notifyAllConnections(payload) {\n  const getPayload = typeof payload === \"function\" ? (origin) => payload(origin) : () => payload;\n\n  Object.keys(connections).forEach((origin) => {\n    Object.values(connections[origin]).forEach(async (conn) => {\n      if (conn.engine) {\n        conn.engine.emit(\"notification\", await getPayload(origin));\n      }\n    });\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}