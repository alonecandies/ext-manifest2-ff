{"version":3,"file":"background.ae411fb3c1887060e1c8.hot-update.js","sources":["/Users/maddie/Desktop/Work/junctionx/fire-phoenix/src/background/index.js"],"sourcesContent":["import LocalStore from \"./local-store\";\nimport browser from \"webextension-polyfill\";\nimport { createEngineStream } from \"json-rpc-middleware-stream\";\nimport PortStream from \"extension-port-stream\";\nimport pump from \"pump\";\nimport { getChainIdStorage, getCurrentPageInfo, getListTrustedApps, openPopup, setupMultiplex } from \"./bgHelper\";\nimport {\n  requestAccounts,\n  switchChain,\n  getChainId,\n  getProviderState,\n  getAccounts,\n  signAndSendTx,\n  personalSign,\n  getBlockNumber,\n  getPermittedAccounts,\n} from \"./jsonRpcApi\";\nimport { nanoid } from \"nanoid\";\nimport { hexToNumber } from \"web3-utils\";\n\nconst JsonRpcEngine = require(\"json-rpc-engine\");\nconst KeyringController = require(\"eth-keyring-controller\");\nconst localStore = new LocalStore();\n\nlet keyringController = null;\nlet password = null;\n\nlet globalData = {\n  selectedAccount: null,\n  chainId: \"0x1\", // hex version of chainId\n  networkVersion: \"1\", // chainId\n  // Flag\n  isOpenRequestedPopup: false,\n  isRejectAccountOnce: false,\n  isRejectSwitchChainOnce: false,\n};\n\nconst connections = {};\nglobal.connections = connections;\n\ninitialize().catch(console.error);\n\nasync function initialize() {\n  const data = await localStore.get();\n\n  keyringController = new KeyringController({\n    initState: data,\n  });\n\n  global.keyringController = keyringController;\n  if (password) {\n    keyringController.submitPassword(password);\n  }\n\n  // eslint-disable-next-line no-undef\n  chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n    console.log(tabs[0].url)\n  })\n\n  // registerLockEvent();\n  // registerUnlockEvent();\n\n  // browser.runtime.onConnect.addListener(connectRemote);\n}\n\n// function registerUnlockEvent() {\n//   keyringController.on(\"unlock\", async () => {\n//     notifyAllConnections(async (origin) => {\n//       const pageInfo = getCurrentPageInfo(connections, origin);\n\n//       return {\n//         method: DAPP_REQUEST_METHODS.METAMASK_UNLOCK_STATE_CHANGED,\n//         params: {\n//           isUnlocked: true,\n//           params: await getPermittedAccounts(keyringController, globalData.selectedAccount, pageInfo),\n//         },\n//       };\n//     });\n//   });\n// }\n\n// function registerLockEvent() {\n//   keyringController.on(\"lock\", async () => {\n//     notifyAllConnections(async () => {\n//       return {\n//         method: DAPP_REQUEST_METHODS.METAMASK_UNLOCK_STATE_CHANGED,\n//         params: {\n//           isUnlocked: false,\n//         },\n//       };\n//     });\n//     globalData.isOpenRequestedPopup = false;\n//   });\n// }\n\n// browser.runtime.onMessage.addListener((request, sender, sendResponse) => {\n//   if (request.type === \"create_new_vault\") {\n//     keyringController.createNewVaultAndKeychain(request.password).then(() => {\n//       password = request.password;\n//       const mnemonic = keyringController.keyrings[0].mnemonic;\n//       sendResponse({ mnemonic: mnemonic });\n//     });\n//   }\n//   if (request.type === \"set_password\") {\n//     password = request.password;\n//     if (password) {\n//       keyringController.submitPassword(password);\n//     } else {\n//       keyringController.setLocked();\n//     }\n//     sendResponse(password);\n//   }\n//   if (request.type === \"get_password\") {\n//     sendResponse(password);\n//   }\n//   if (request.type === \"store_vault\") {\n//     if (request.vault) {\n//       localStore.set(request.vault);\n//       sendResponse(request.vault);\n//     } else {\n//       const vault = keyringController.store.getState();\n//       localStore.set(vault);\n//       sendResponse(vault);\n//     }\n//   }\n//   if (request.type === \"create_new_vault_and_restore\") {\n//     keyringController\n//       .createNewVaultAndRestore(request.password, request.mnemonic)\n//       .then((res) => {\n//         const vault = keyringController.store.getState();\n//         password = request.password;\n//         localStore.set(vault);\n//         sendResponse({ vault, isError: false });\n//       })\n//       .catch((err) => {\n//         sendResponse({ error: err.message, isError: true });\n//       });\n//   }\n//   if (request.type === \"set_selected_account\") {\n//     globalData.selectedAccount = request.selectedAccount;\n//     notifyAllConnections(async (origin) => {\n//       const pageInfo = getCurrentPageInfo(connections, origin);\n//       return {\n//         method: DAPP_REQUEST_METHODS.METAMASK_ACCOUNTS_CHANGED,\n//         params: await getPermittedAccounts(keyringController, globalData.selectedAccount, pageInfo),\n//       };\n//     });\n//     sendResponse(globalData.selectedAccount);\n//   }\n//   if (request.type === \"revoke_trusted_app\") {\n//     if (request.address === globalData.selectedAccount) {\n//       let origin = \"https://\" + request.domain;\n//       notifyConnections(origin, async () => {\n//         return {\n//           method: DAPP_REQUEST_METHODS.METAMASK_ACCOUNTS_CHANGED,\n//           params: [],\n//         };\n//       });\n//     }\n//     sendResponse(true);\n//   }\n//   if (request.type === \"set_chain_id\") {\n//     globalData.chainId = \"0x\" + request.chainId.toString(16);\n//     globalData.networkVersion = request.chainId.toString();\n//     notifyAllConnections(async () => {\n//       return {\n//         method: DAPP_REQUEST_METHODS.METAMASK_CHAIN_CHANGED,\n//         params: { chainId: globalData.chainId, networkVersion: globalData.networkVersion },\n//       };\n//     });\n//     sendResponse(true);\n//   }\n//   if (request.type === \"close_popup_window\") {\n//     keyringController.removeAllListeners(\"unlock\");\n//     globalData.isOpenRequestedPopup = false;\n//     registerUnlockEvent();\n//   }\n//   if (request.type === \"log\") {\n//     console.log(request.message);\n//   }\n//   if (request.type === \"get_page_info\") {\n//     const pageInfo = getCurrentPageInfo(connections, request.url);\n//     sendResponse(pageInfo);\n//   }\n//   if (request.type === \"set_reject_account_once\") {\n//     globalData.isRejectAccountOnce = request.isRejected;\n//     sendResponse(request.isRejected);\n//   }\n//   if (request.type === \"set_reject_switch_chain_once\") {\n//     globalData.isRejectSwitchChainOnce = request.value;\n//     sendResponse(request.isRejectSwitchChainOnce);\n//   }\n//   if (request.type === \"get_chain_id\") {\n//     sendResponse(globalData.chainId);\n//   }\n//   return true;\n// });\n\n// /**\n//  * A runtime.Port object, as provided by the browser:\n//  *\n//  * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port\n//  * @typedef Port\n//  * @type Object\n//  */\n\n// /**\n//  * @param {Port} remotePort - The port provided by a new context.\n//  */\n// function connectRemote(remotePort) {\n//   const connectionStream = new PortStream(remotePort);\n//   const { sender } = remotePort;\n//   const mux = setupMultiplex(connectionStream);\n//   const outStream = mux.createStream(\"metamask-provider\");\n\n//   const engine = new JsonRpcEngine();\n//   const origin = new URL(sender.url).origin;\n\n//   engine.push(async (req, res, next, end) => {\n//     try {\n//       // Change global variables\n//       if (req.params && req.method === DAPP_REQUEST_METHODS.METAMASK_SEND_DOMAIN_METADATA) {\n//         const pageInfo = {\n//           title: req.params.name,\n//           domain: req.params.icon.split(\"/\")[2],\n//           icon: req.params.icon,\n//         };\n//         const keyUrl = Object.keys(connections).find((url) => url === origin);\n//         if (!!keyUrl) {\n//           connections[keyUrl].page_info = pageInfo;\n//         }\n//       }\n//       next();\n//     } catch (error) {\n//       console.log(error);\n//     }\n//   });\n\n//   engine.push(async (req, res, next, end) => {\n//     console.log(req);\n\n//     try {\n//       if (Object.values(DAPP_REQUEST_METHODS).includes(req.method)) {\n//         const { isUnlocked } = keyringController.memStore.getState();\n//         const listApps = getListTrustedApps(globalData.selectedAccount);\n//         const pageInfo = getCurrentPageInfo(connections, origin);\n//         const chainIdStorage = getChainIdStorage();\n//         // Request account\n//         if (\n//           !!pageInfo &&\n//           !(isUnlocked && listApps?.find((app) => app.domain === pageInfo.domain)) &&\n//           req.method === DAPP_REQUEST_METHODS.ETH_REQUEST_ACCOUNTS\n//         ) {\n//           if (!globalData.isOpenRequestedPopup && !globalData.isRejectAccountOnce) {\n//             globalData.isRejectAccountOnce = true;\n//             globalData.isOpenRequestedPopup = true;\n//             await openPopup(`method=${req.method}&origin=${origin}`, () => {\n//               globalData.isOpenRequestedPopup = false;\n//               globalData.isRejectAccountOnce = false;\n//             });\n//           }\n//         }\n\n//         if (\n//           req.method === DAPP_REQUEST_METHODS.WALLET_SWITCH_ETH_CHAIN &&\n//           chainIdStorage !== hexToNumber(req.params[0].chainId)\n//         ) {\n//           globalData.isOpenRequestedPopup = true;\n//           await openPopup(`method=${req.method}&origin=${origin}`);\n//         }\n\n//         if (\n//           [\n//             DAPP_REQUEST_METHODS.PERSONAL_SIGN,\n//             DAPP_REQUEST_METHODS.ETH_SEND_TRANSACTION,\n//             // DAPP_REQUEST_METHODS.WALLET_SWITCH_ETH_CHAIN,\n//           ].includes(req.method)\n//         ) {\n//           globalData.isOpenRequestedPopup = true;\n//           await openPopup(`method=${req.method}&origin=${origin}`);\n//         }\n//       }\n//       next();\n//     } catch (error) {\n//       globalData.isOpenRequestedPopup = false;\n//       console.log(error);\n//     }\n//   });\n\n//   engine.push(async (req, res, next, end) => {\n//     const pageInfo = getCurrentPageInfo(connections, origin);\n\n//     const params = {\n//       req,\n//       res,\n//       next,\n//       end,\n//       keyringController,\n//       selectedAccount: globalData.selectedAccount,\n//       chainId: globalData.chainId,\n//       networkVersion: globalData.networkVersion,\n//       isOpenRequestedPopup: globalData.isOpenRequestedPopup,\n//       pageInfo,\n//     };\n//     getProviderState(params);\n//     getAccounts(params);\n//     requestAccounts(params);\n//     switchChain(params);\n//     getChainId(params);\n//     signAndSendTx(params);\n//     personalSign(params);\n//     getBlockNumber(params);\n//   });\n\n//   // setup connection\n//   const providerStream = createEngineStream({ engine });\n\n//   const connectionId = addConnection(origin, { engine });\n\n//   pump(outStream, providerStream, outStream, (err) => {\n//     engine._middleware.forEach((mid) => {\n//       if (mid.destroy && typeof mid.destroy === \"function\") {\n//         mid.destroy();\n//       }\n//     });\n//     connectionId && removeConnection(origin, connectionId);\n//     if (err) {\n//       console.log(err);\n//     }\n//   });\n\n//   remotePort.onMessage.addListener((msg) => {\n//     console.log(msg, remotePort);\n//   });\n// }\n\n/**\n * Adds a reference to a connection by origin. Ignores the 'metamask' origin.\n * Caller must ensure that the returned id is stored such that the reference\n * can be deleted later.\n *\n * @param {string} origin - The connection's origin string.\n * @param {Object} options - Data associated with the connection\n * @param {Object} options.engine - The connection's JSON Rpc Engine\n * @returns {string} The connection's id (so that it can be deleted later)\n */\nfunction addConnection(origin, { engine }) {\n  if (origin === \"metamask\") {\n    return null;\n  }\n\n  if (!connections[origin]) {\n    connections[origin] = {};\n  }\n\n  const id = nanoid();\n  connections[origin][id] = {\n    engine,\n  };\n\n  return id;\n}\n\n/**\n * Deletes a reference to a connection, by origin and id.\n * Ignores unknown origins.\n *\n * @param {string} origin - The connection's origin string.\n * @param {string} id - The connection's id, as returned from addConnection.\n */\nfunction removeConnection(origin, id) {\n  const data = connections[origin];\n  if (!data) {\n    return;\n  }\n\n  delete data[id];\n\n  if (Object.keys(data).length === 0) {\n    delete connections[origin];\n  }\n}\n\n/**\n * Closes all connections for the given origin, and removes the references\n * to them.\n * Ignores unknown origins.\n *\n * @param {string} origin - The origin string.\n */\nfunction removeAllConnections(origin) {\n  const connections = connections[origin];\n  if (!connections) {\n    return;\n  }\n\n  Object.keys(connections).forEach((id) => {\n    removeConnection(origin, id);\n  });\n}\n\n/**\n * Causes the RPC engines associated with the connections to the given origin\n * to emit a notification event with the given payload.\n *\n * The caller is responsible for ensuring that only permitted notifications\n * are sent.\n *\n * Ignores unknown origins.\n *\n * @param {string} origin - The connection's origin string.\n * @param {unknown} payload - The event payload.\n */\nfunction notifyConnections(origin, payload) {\n  const connections = global.connections[origin];\n  const getPayload = typeof payload === \"function\" ? (origin) => payload(origin) : () => payload;\n\n  if (connections) {\n    Object.values(connections).forEach(async (conn) => {\n      if (conn.engine) {\n        conn.engine.emit(\"notification\", await getPayload(origin));\n      }\n    });\n  }\n}\n\n/**\n * Causes the RPC engines associated with all connections to emit a\n * notification event with the given payload.\n *\n * If the \"payload\" parameter is a function, the payload for each connection\n * will be the return value of that function called with the connection's\n * origin.\n *\n * The caller is responsible for ensuring that only permitted notifications\n * are sent.\n *\n * @param {unknown} payload - The event payload, or payload getter function.\n */\nexport function notifyAllConnections(payload) {\n  const getPayload = typeof payload === \"function\" ? (origin) => payload(origin) : () => payload;\n\n  Object.keys(connections).forEach((origin) => {\n    Object.values(connections[origin]).forEach(async (conn) => {\n      if (conn.engine) {\n        conn.engine.emit(\"notification\", await getPayload(origin));\n      }\n    });\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AADA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}